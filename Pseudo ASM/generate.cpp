//
//  generate.cpp
//  Pseudo ASM
//
//  Created by Indi Kernick on 25/2/18.
//  Copyright Â© 2018 Indi Kernick. All rights reserved.
//

#include "generate.hpp"

#include <cassert>

const std::string_view pre =
R"(// This file was generated by the Pseudo ASM compiler

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

typedef union {
  void *p;
  uint64_t q;
  uint32_t l;
  uint16_t w;
  uint8_t b;
} Register;

typedef struct {
  uint8_t *mem;
  size_t size;
  size_t capacity;
} Stack;

static Stack stack_alloc(const size_t capacity) {
  Stack stack;
  stack.mem = (uint8_t *)malloc(capacity);
  if (stack.mem == NULL) {
    printf("Failed to allocate %zu bytes\n", capacity);
    exit(1);
  }
  stack.size = 0;
  stack.capacity = capacity;
  return stack;
}

static void stack_free(const Stack stack) {
  free(stack.mem);
}

static void stack_growToFit(Stack *const stack, const size_t extra) {
  if (extra > stack->capacity - stack->size) {
    stack->capacity = stack->capacity * 2;
    stack->mem = (uint8_t *)realloc(stack->mem, stack->capacity);
    if (stack->mem == NULL) {
      printf("Failed to allocate %zu bytes\n", stack->capacity);
      exit(1);
    }
  }
}

static void stack_push(Stack *const stack, const void *const src, const size_t size) {
  stack_growToFit(stack, size);
  memcpy(stack->mem + stack->size, src, size);
  stack->size += size;
}

static void stack_pop(Stack *const stack, void *const dst, const size_t size) {
  if (stack->size < size) {
    printf("Stackunderflow.com\n");
    exit(1);
  }
  memcpy(dst, stack->mem + stack->size - size, size);
  stack->size -= size;
}

int main() {
  Register r[8];
  Stack stack = stack_alloc(32 * 1024);
  void *iptr = NULL;
  int64_t cflags = 0;
  
  goto PastMainRet;
MainRet:
  stack_free(stack);
  return r[0].l;
PastMainRet:
  iptr = &&MainRet;
  stack_push(&stack, &iptr, 8);
  
  goto LABEL_start;
  
  // begin compiled code
)";

const std::string_view post = R"(
  // end compiled code
}
)";

using IRIter = std::vector<IR>::const_iterator;
const std::string_view instrIndent = "        ";
size_t callSiteIndex = 0;

std::ostream &operator<<(std::ostream &out, const Register reg) {
  out << "r[" << static_cast<int>(reg.index) << "].";
  if (reg.size == Register::BYTE) {
    return out << 'b';
  } else if (reg.size == Register::WORD) {
    return out << 'w';
  } else if (reg.size == Register::LONG) {
    return out << 'l';
  } else if (reg.size == Register::QUAD) {
    return out << 'q';
  }
  assert(false);
}

std::ostream &operator<<(std::ostream &out, const NumberLiteral num) {
  if (num.sign) {
    return out << num.s << "ll";
  } else {
    return out << num.u << "ull";
  }
}

std::ostream &operator<<(std::ostream &out, const IR ir) {
  if (ir.type == IRType::OP_REGISTER) {
    return out << ir.reg;
  } else if (ir.type == IRType::OP_NUM) {
    return out << ir.num;
  }
  assert(false);
}

std::ostream &operator<<(std::ostream &out, const Label label) {
  return out << std::string_view(label.data, label.size);
}

void printInstrTokens(std::ostream &out, IRIter i) {
  out << i->token.line << ':' << i->token.col << ' ';
  do {
    out << i->token.str;
    out << ' ';
    ++i;
  } while (i->type != IRType::END_OP);
  out << '\n';
}

void genInstr(std::ostream &out, IRIter &i) {
  out << instrIndent << "// ";
  printInstrTokens(out, i);
  out << instrIndent;
  const Instr instr = (i++)->instr;
  switch (instr) {
    case Instr::MOV:
      out << (i++)->reg << " = " << *(i++) << ";";
      break;
    case Instr::ADD:
      out << (i++)->reg << " += " << *(i++) << ";";
      break;
    case Instr::SUB:
      out << (i++)->reg << " -= " << *(i++) << ";";
      break;
    case Instr::MUL:
      out << (i++)->reg << " *= " << *(i++) << ";";
      break;
    case Instr::DIV:
      out << (i++)->reg << " /= " << *(i++) << ";";
      break;
    case Instr::AND:
      out << (i++)->reg << " &= " << *(i++) << ";";
      break;
    case Instr::OR:
      out << (i++)->reg << " |= " << *(i++) << ";";
      break;
    case Instr::XOR:
      out << (i++)->reg << " ^= " << *(i++) << ";";
      break;
    case Instr::NOT:
      out << i->reg << " = ~" << i->reg << ";";
      ++i;
      break;
    case Instr::CMP:
      out << "cflags = " << *(i++) << " - " << *(i++) << ";";
      break;
    case Instr::JE:
      out << "if (cflags == 0) goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::JNE:
      out << "if (cflags != 0) goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::JL:
      out << "if (cflags < 0) goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::JLE:
      out << "if (cflags <= 0) goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::JG:
      out << "if (cflags > 0) goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::JGE:
      out << "if (cflags >= 0) goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::JMP:
      out << "goto LABEL_" << (i++)->label << ';';
      break;
    case Instr::CALL:
      out << "iptr = &&CALL_SITE_" << callSiteIndex << ";\n";
      out << instrIndent << "stack_push(&stack, &iptr, 8);\n";
      out << instrIndent << "goto LABEL_" << (i++)->label << ";\n";
      out << "CALL_SITE_" << callSiteIndex << ':';
      ++callSiteIndex;
      break;
    case Instr::RET:
      out << "stack_pop(&stack, &iptr, 8);\n";
      out << instrIndent << "goto *iptr;";
      break;
    case Instr::SYSCALL:
      out << "// syscall";
      break;
    case Instr::PUSH:
      out << "stack_push(&stack, &" << i->reg << ", sizeof(" << i->reg << "));";
      ++i;
      break;
    case Instr::POP:
      out << "stack_pop(&stack, &" << i->reg << ", sizeof(" << i->reg << "));";
      ++i;
      break;
  }
  out << '\n';
  // skipping IRType::END_OP
  ++i;
}

void genLabel(std::ostream &out, IRIter &i) {
  out << "// " << i->token.line << ':' << i->token.col << '\n';
  out << "LABEL_" << std::string_view(i->label.data, i->label.size) << ":\n";
  ++i;
}

void genLine(std::ostream &out, IRIter &i) {
  if (i->type == IRType::INSTRUCTION) {
    genInstr(out, i);
  } else if (i->type == IRType::LABEL) {
    genLabel(out, i);
  }
}

void generate(std::ostream &out, const std::vector<IR> &irs) {
  out << pre;
  
  for (auto i = irs.cbegin(); i != irs.cend();) {
    genLine(out, i);
  }
  
  out << post;
}
