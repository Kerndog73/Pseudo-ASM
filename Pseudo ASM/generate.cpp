//
//  generate.cpp
//  Pseudo ASM
//
//  Created by Indi Kernick on 25/2/18.
//  Copyright Â© 2018 Indi Kernick. All rights reserved.
//

#include "generate.hpp"

const std::string_view pre =
R"(// This file was generated by the Pseudo ASM compiler

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

typedef union {
  void *p;
  uint64_t q;
  uint32_t l;
  uint16_t w;
  uint8_t b;
} Register;

typedef struct {
  uint8_t *mem;
  size_t size;
  size_t capacity;
} Stack;

Stack stack_alloc(const size_t capacity) {
  Stack stack;
  stack.mem = malloc(capacity);
  if (stack.mem == NULL) {
    printf("Failed to allocate %zu bytes\n", capacity);
    exit(1);
  }
  stack.size = 0;
  stack.capacity = capacity;
  return stack;
}

void stack_free(const Stack stack) {
  free(stack.mem);
}

void stack_growToFit(Stack *const stack, const size_t extra) {
  if (extra > stack->capacity - stack->size) {
    stack->capacity = stack->capacity * 2;
    stack->mem = realloc(stack->mem, stack->capacity);
    if (stack->mem == NULL) {
      printf("Failed to allocate %zu bytes\n", stack->capacity);
      exit(1);
    }
  }
}

void stack_push(Stack *const stack, const void *const src, const size_t size) {
  stack_growToFit(stack, size);
  memcpy(stack->mem + stack->size, src, size);
  stack->size += size;
}

void stack_pop(Stack *const stack, void *const dst, const size_t size) {
  if (stack->size < size) {
    printf("Stackunderflow.com\n");
    exit(1);
  }
  memcpy(dst, stack->mem + stack->size - size, size);
  stack->size -= size;
}

int main() {
  Register r[8];
  Stack stack = stack_alloc(32 * 1024);
  void *iptr = NULL;
  
  goto PastMainRet;
MainRet:
  stack_free(stack);
  return r[0].l;
PastMainRet:
  iptr = &&MainRet;
  stack_push(&stack, &iptr, 8);
  
  goto LABEL_start;
  
LABEL_start:
  stack_pop(&stack, &iptr, 8);
  goto *iptr;
  
  // begin compiled code
)";

const std::string_view post = R"(
  // end compiled code
}
)";

void generate(std::ostream &out, const std::vector<IR> &irs) {
  out << pre;
  
  
  
  out << post;
}
